EXCERCISE
-- using COUNT in GROUP BY
SELECT
	COUNT(firstName) AS total_customers,
	SUM(score) AS total_score,
	country
FROM sales.Customers
GROUP BY country

-- show new column
SELECT 'hello world' AS static_value

-- DDL
CREATE TABLE persons(
	id INT NOT NULL,
	person_name VARCHAR(50) NOT NULL,
	birth_date DATE,
	phone VARCHAR(15) NOT NULL,
	CONSTRAINT pk_persons PRIMARY KEY (id)
)
ALTER TABLE persons
ADD email VARCHAR(30) NOT NULL
ALTER TABLE persons
DROP COLUMN email
DROP TABLE persons

-- DML
INSERT INTO sales.customers (CustomerID, FirstName, country, score)
VALUES(6, 'Anna', 'UK', '0'),
(7, 'Sam', 'India', '100')
INSERT INTO sales.customers
VALUES(8, 'Anna', 'India', '50')

SELECT * FROM sales.customers

UPDATE sales.customers
SET score = 200, lastName = 'Berry'
WHERE customerID = 6

SELECT * FROM sales.customers
-- DELETE FROM sales.customers
WHERE CustomerID > 7

TRUNCATE TABLE persons
DELETE FROM persons
/* TRUNCATE removes all rows quickly 
without logging, 
while DELETE removes specific rows 
with conditions and supports rollback */


-- BETWEEN X AND Y operator
-- Underscore in LIKE _

-- Data enrichment = getting extra data from different table. INNER, LEFT
-- Recombine data = detting extra data from here and there to have a big picture. LEFT
-- Check existance.  INNER

-- full join
-- left anti join = left join where b.key is null
-- full anti join = full join where b.key is null OR a.key is null
-- inner join = left join where X is not null

-- cross join = all combinations
SELECT *
FROM sales.customers
CROSS JOIN sales.orders

-- order by only once per query, while group by, .. can be used in many select combined with union
-- UNION ALL doesnt remove duplicates
-- EXCEPT not found in second query
-- INTERSECT only common values

GETDATE() today

DATE(your_date)

MONTH(your_date)

YEAR(your_date)

DATEPART(year, your_date)
		quarter
		hour
		week

DATENAME(month, your_date) -- > January
DATENAME(weekday, your_date) -- > monday

DATETRUNC(minute, your_time)   -> reset everything less than that
		second
		hour
		day
		month   -- day resets to 1
		year	-- month resets to 1

EOMONTH(your_date)   -- END OF MONTH: date with the last day of this month aka 2025-2-28

CASE(DATETRUNC(minute, your_time) AS DATE)

SELECT
DATENAME(month, OrderDate) AS OrderDate,
COUNT(*) AS NrOfOrders
FROM Sales.Orders
GROUP BY DATENAME(month, OrderDate)

SELECT
OrderDate
FROM Sales.Orders

DAY, MONTH, YEAR, DATEPART -> INT
DATENAME -> STRING
DATETRUNC -> DATETIME
EOMONTH -> DATE

FORMAT
MM/dd/YY = 08/20/2025
MMM YYYY = Aug 2025


FORMAT(CreationTime, 'dd')		01
FORMAT(CreationTime, 'ddd')		Wed
FORMAT(CreationTime, 'dddd')	Wednesday
FORMAT(CreationTime, 'MM')		01
FORMAT(CreationTime, 'MMM')		Jan
FORMAT(CreationTime, 'MMMM')	January

FORMAT(CreationTime, 'tt')		AM/PM


CONVERT(INT, '123')
CAST('123' AS INT)

DATEADD(year, -2, OrderDate)
		month
		day

DATEDIFF(year, OrderDate, ShipDate)
		month
		day


LAG = Access value from previous row
LAG(OrderDate) OVER (ORDER BY OrderDate)


ISDATE(value) returns 1 for true and 0 for false


SELECT
	OrderDate,
	ISDATE(OrderDate),
	CASE WHEN ISDATE(OrderDate) = 1 THEN CAST(OrderDate AS DATE) 
		ELSE '9999-01-01'
	END NewOrderDate
	FROM(...some dates...)t


ISNULL(value, replacement_value) -- fast but: SQL Server = ISNULL
													Oracle = NVL
													MySql = IFNULL

COALESCE(value1, value2, value3,...) --  uporabi vrednosti ki ni null
-- slow but available in all Databases

AVG, SUM, .. ignores NULL
COUNT doesnt ignore NULL


SELECT 
	CustomerID,
	Score,
	AVG(Score) OVER() AvgScores,
	AVG(COALESCE(Score, 0)) OVER() AvgScore2
FROM Sales.Customers

NULL + 5 = NULL
NULL + 'a' = NULL

SELECT
	FirstName + '' + COALESCE(LastName, '') AS FullName,
	*,
	COALESCE(Score, 0) + 10 AS Score2
FROM Sales.Customers

-- First sort nulls to be at the end, then ASC values
--CASE WHEN Score IS NULL THEN 1 ELSE 0 END Flag
ORDER BY CASE WHEN Score IS NULL THEN 1 ELSE 0 END, Score


NULLIF(value1, value2) -- return NULl if values equal, else return value1

Sales / NULLIF(Quantity, 0) AS Price -- prevent division by 0

-- LEFT ANTI JOIN = LEFT JOIN + IS NULL
SELECT
c.*,
o.OrderID
FROM Sales.Customers c
LEFT JOIN Sales.orders o
ON c.CustomerID = o.customerID

WITH Query_name AS(
	SELECT NULL AS Subquery UNION ALL
	SELECT ''				UNION ALL
	SELECT ' '				UNION ALL
	SELECT '  '
) -- '_' and '__' is considered the same, use UNION ALL
SELECT 
*,
DATALENGTH(Subquery) SubqueryLength
FROM Query_name

--		Performance,	Storage
-- NULL =	Best,		very minimal
-- ''	=	Fast
-- '_'	=	Slow

TRIM(Category)					AS Policy1
NULLIF(TRIM(Category), '')		AS Policy2
COALESCE(	NULLIF(TRIM(Category), '')	, 'unknown')	AS Policy3

-- policy 2 better for storage
-- policy 3 better for showing data to others

CASE
	WHEN condition1			 THEN result1
	WHEN country2 = 'poland2' THEN result2
	...
	ELSE result -- skipable
END

CASE Country	
	WHEN 'Germany' THEN result1
	WHEN 'India' THEN result2
	...
	ELSE result -- skipable
END

-- CASE can be used anywhere, even group by



SELECT 
	CustomerID,
	LastName,
	Score,
	CASE
		WHEN Score IS NULL THEN 0
		ELSE Score
	END ScoreCleaned,
	AVG(Score) OVER() AS AvgScore,
	AVG(CASE
			WHEN Score IS NULL THEN 0
			ELSE Score
		END) OVER () AvgCustomerClean
FROM Sales.Customers


/* --------------------------------------
		AGGREGATE FUNC & WIN FUNC	
   --------------------------------------
*/
SUM(), COUNT(), AVG()
GROUP BY CustomerID


COUNT, SUM, AVG, MAX, MIN, 
ROW_NUMBER, RANK, DENSE_RANK, CUME_DIST, PERCENT_RANK, NTILE
LEAD, LAG, FIRST_VALUE, LAST_VALUE

-- win func can be only used in select and order by
-- cannot use win func inside win func

SELECT
	Sales,
	SUM(Sales) OVER(PARTITION BY ProductID) SumSales,
	RANK() OVER (ORDER BY Sales DESC) RankSales,
	SUM(Sales) OVER(ORDER BY MONTH(CreationTime)
		ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING
	),
	SUM(Sales) OVER(ORDER BY MONTH(CreationTime)
		ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
	),
	SUM(Sales) OVER(ORDER BY MONTH(CreationTime))
	,
	SUM(Sales) OVER()
FROM Sales.Orders

COUNT(*)
COUNT(Sales)
COUNT(1)

SELECT
	OrderID,
	OrderDate,
	Sales,
	--COUNT(*) OVER() TotalOrders,
	--COUNT(1) OVER(PARTITION BY CustomerID) OrdersByCustomer
	SUM(Sales) OVER () TotalSales,
	CONVERT(FLOAT, Sales) / SUM(Sales) OVER (PARTITION BY Sales) * 100
FROM Sales.Orders

-- RUNNING			goes from start to finish
-- ROLLING TOTAL	uses shifting window

-- two same-valued sales are numbered one after another
ROW_NUMBER()

-- two same-ranked sales have the same rank, next standing is skipped
RANK()

-- two same-ranked sales have the same rank, next standing is counted normally
DENSE_RANK()

NTILE(2) -- numbers buckets = num of rows / num of buckets
-- use buckets to set into groups: high, medium, low

--CUME_DIST = pos of num / num of rows
--(same values same last position value)

--PERCENT_RANK = pos of num  - 1 / num of rows - 1 
--(same values same first position value)

LEAD(Sales, optionalOffset(how many rows to jump), default_value)
LEAD(Sales, 1, NULL)

LAG = LEAD negated
LAG = get previous value

SELECT
	*, 
	ROUND(CAST((CurrentMonthSales - PreviousMonth) AS FLOAT) / PreviousMonth *100, 1) Change
FROM (
	SELECT
		MONTH(OrderDate) AS OrderMonth,
		SUM(Sales) AS CurrentMonthSales,
		LAG(SUM(Sales)) OVER(ORDER BY MONTH(OrderDate)) PreviousMonth
	FROM Sales.Orders
	GROUP BY MONTH(OrderDate)
)t

FIRST_VALUE -- always first row
LAST_VALUE -- always same row, not last row because default is:
--RANGE BETWEEN UNBOUNCED PRECEDING AND CURRENT ROW
--instead of:
--RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING

LAST_VALUE = FIRST_VALUE with ORDER DESC

DWH = special DB that collects and integrates
data from different sources to enable analytics
and support decision-making



SELECT 
*
FROM INFORMATION_SCHEMA.COLUMNS

-- win func can be done with subquery too

non-correlated subquery = can be run seperately
correlated subquery = works as part of main query because it is connected to main using ON a.id=b.id


CTE + query is better than Main query + subquery


-- Recursive CTE
WITH Series AS(
	-- Anchor Query
	SELECT
	1 AS MyNumber
	UNION ALL
	-- Recuresive Query
	SELECT
	MyNumber + 1
	FROM Series
	WHERE MyNumber < 20
)
-- Main query
SELECT
*
FROM Series
OPTION (MAXRECURSION 10)


WITH CTE_Emp_hierarhy AS
(
	SELECT
		EmployeeID,
		FirstName,
		ManagerID,
		0 AS Level
	FROM Sales.Employees
	WHERE ManagerID IS NULL
	UNION ALL
	SELECT
		e.EmployeeID,
		e.FirstName,
		e.ManagerID,
		Level + 1
	FROM Sales.Employees AS e
	INNER JOIN CTE_Emp_hierarhy ceh
	ON e.ManagerID = ceh.EmployeeID

)
SELECT * FROM CTE_Emp_hierarhy

--IF OBJECT_ID('Sales.V_monthly_summary', 'V') IS NOT NULL
	--DROP VIEW Sales.V_monthly_summary
--GO
--CREATE VIEW Sales.V_monthly_summary AS
CREATE OR REPLACE VIEW Sales.V_monthly_summary AS
(
	SELECT
	DATENAME(MONTH, OrderDate) OrderMonth,
	SUM(Sales) TotalSales,
	COUNT(OrderID) AS TotalOrders
	FROM Sales.Orders
	GROUP BY DATENAME(MONTH, OrderDate)
)
SELECT
*
FROM
Sales.V_monthly_summary

--DROP VIEW Sales.V_monthly_summary


--MySQL, Postgres, Oracle:
CREATE TABLE NAME AS(
	SELECT ...
	FROM  ...
	WHERE ...
)

--SqlServer:
SELECT *
INTO new_tabel
FROM ...
WHERE ...




IF OBJECT_ID('Sales.MontlyOrders', 'U') IS NOT NULL
	DROP TABLE Sales.MonthlyOrders
	GO
	SELECT ....


-- temp table. ttl = session
SELECT
*
INTO #Orders
FROM Sales.Orders

---------------------------------
-- PROCEDURES
---------------------------------
CREATE PROCEDURE ProcedureName AS
BEGIN
--SQL Query
END
EXEC ProcedureName

CREATE OR ALTER PROCEDURE TestProc AS
BEGIN
	SELECT TOP 1 CustomerID FROM Sales.Orders
END
EXEC TestProc


ALTER PROCEDURE TestProc @Country NVARCHAR(50) = 'USA' 
AS
BEGIN
	
	DECLARE @TotalCustomers INT, @AvgScore FLOAT

	
	IF EXISTS(SELECT 1 FROM Sales.Customers WHERE Score IS NULL AND Country = 'Germany')
		BEGIN
		PRINT('Updating NULL Scores to 0')
			UPDATE Sales.Customers
			SET Score = 0
			WHERE Score IS NULL AND Country = @Country
		END
	ELSE
		BEGIN
			PRINT('No NULL Scores found')
		END


	-- Report
	SELECT
		@TotalCustomers = COUNT(*),
		@AvgScore = AVG(Score)
	FROM Sales.Customers
	WHERE Country = @Country;

	PRINT 'Great Success ' + @Country + ' : ' + CAST(@TotalCustomers AS NVARCHAR)
END
EXEC TestProc @Country = 'Germany'
EXEC TestProc @Country = 'USA'



BEGIN TRY
	...
END TRY
BEGIN CATCH
	PRINT(ERROR_MESSAGE()) 
	PRINT(CAST(ERROR_NUMBER() AS NVARCHAR)) 
	PRINT(CAST(ERROR_LINE()	AS NVARCHAR)
	PRINT(ERROR_PROCEDURE()	AS NVARCHAR)
END CATCH


CREATE TRIGGER TriggerName ON TableName
AFTER INSERT, UPDATE, DELETE
BEGIN
	...
END



CREATE TABLE Sales.EmployeeLogs(
	LogID INT IDENTITY(1,1) PRIMARY KEY, -- IDENTITY(1,1) = autoincrementing, starting at 1, step by 1
	EmployeeID INT,
	LogMessage VARCHAR(255),
	LogDate DATE
)


CREATE TRIGGER trg_AfterInsertEmployee ON Sales.Employees
AFTER INSERT
AS
BEGIN
	INSERT INTO Sales.EmployeeLogs(EmployeeID, LogMessage, LogDate)
	SELECT 
		EmployeeID,
		'New employee added = ' + CAST(EmployeeID AS VARCHAR),
		GETDATE()
	FROM INSERTED -- virtual table holding copy of rows being insert into target table, a.k.a Sales.Employees
END

INSERT INTO Sales.Employees
VALUES(6, 'Maria', 'Doe', 'HR', '1988-01-12', 'F', 80000, 3)

SELECT * FROM Sales.EmployeeLogs


-- Clustered index
	--physically sorts and stores rows
	--one index per table
	--faster read
	--slower write
	--storage.efficient
		--unique column
		--improve range query performace
		--not frequently modified column

-- Non-clustered index
	--seperate stricture with pointers to data
	--multiple indexes allowed
	--slower read
	--faster write
	--requires additonal storage
		--columns frequently used in search conditions and joins
		--exact match queries

-- nonclustered is a default
CREATE [CLUSTERED | NONCLUSTERED] INDEX index_name ON table (column1 [ASC | DESC], column2, ..)


--PK automatically creates clustered index

SELECT *
INTO Sales.DBCustomers
FROM Sales.Customers

-- Now Sales.DBCustomers is a heap strcutre with an index

CREATE CLUSTERED INDEX idx_DBCustomers_CustomerID
ON Sales.DBCustomers (CustomerID)

-- Cannot create more than 1 clustered index per table

DROP INDEX idx_DBCustomers_CustomerID ON Sales.DBCustomers

-- If index uses (Country, Score)
-- query must be:
-- WHERE Country = 'USA' AND Score > 500
-- not:
-- WHERE Score > 500 AND Country = 'USA'

--Index uses leftmost prefex role so searching by
-- WHERE Country = 'USA' only does use index search


--rowstore index
	--less efficient in storage
	--fair speed for read/write
	--lower IO efficiency (retrives all columns)
	--OLTP(Transactional) (commerce, banking, financial systems, order processing)
	--quick access to complete records
	--high frequency transaction applications

--columnstore index
	--highly efficient with compression
	--fast read, slow write
	--higher IO efficiency (retrives specific columns)
	--OLAP(Analytical) (DWH, BI, Reporting, Analytics)

CREATE [CLUSTERED | NONCLUSTERED] [COLUMNSTORE] INDEX index_name
--Default is ROWSTORE
-- rowstore: specify on which columns there is an index
-- columnstore: dont specify any column


CREATE CLUSTERED COLUMNSTORE INDEX idx_DBCustomers_CS
ON Sales.DBCustomers

--on columnstore index per table, and one has to decide to make it clustered or nonclustered

DROP INDEX idx_DBCustomers_CS ON Sales.DBCustomers

CREATE UNIQUE [CLUSTERED | NONCLUSTERED] COLUMNSTORE INDEX index_name
-- default is non unique


--Cant use filtered index on columnstore or clustered index
CREATE NONCLUSTERED INDEX inx_Customers_Country
ON Sales.Customers (Country)
WHERE Country = 'USA'


--HEAP
--no index
--fast inserts
--unimportant tables 

--CLUSTERED INDEX
--PK or date column
--OLTP

--COLUMNSTORE INDEX
--big comlex analytical queries with data aggregations
--compresses data and reduces table size
--OLAP

--NONCLUSTERED INDEX
--non PK columns
--FK, joins, filters

--FILTERED INDEX
--target subset to reduce size

--UNIQUE INDEX
--data uniqueness
--improved query speed slightly because when record found it returns it


--List all indexes on a specific table
sp_helpindex 'Sales.DBCustomers'

SELECT * FROM sys.indexes

SELECT 
	tbl.name AS tableName,
	idx.name AS indexName, 
	idx.type_desc AS indexType ,
	idx.is_primary_key AS isPrimaryKey,
	idx.is_unique AS isUnique,
	idx.is_disabled AS isDisabled,
	s.user_seeks,
	s.user_scans,
	s.user_lookups,
	s.user_updates,
	COALESCE( s.last_user_seek, s.last_user_scan)
FROM sys.indexes idx
JOIN sys.tables tbl
ON idx.object_id = tbl.object_id
LEFT JOIN sys.dm_db_index_usage_stats s
ON s.object_id = idx.index_id
ORDER BY tbl.name, idx.name

--DMV (Dynamic Management View)
SELECT * FROM sys.dm_db_index_usage_stats

--in cache
SELECT * FROM sys.dm_db_missing_index_details


SELECT
	tbl.name AS TableName, 
	col.name AS IndexColumn, 
	idx.name AS IndexName,
	idx.type_desc AS IndexType,
	COUNT(1) OVER (PARTITION BY tbl.name, col.name) ColumnCount  -- how many indexes per column, 1 ok
FROM sys.indexes idx
JOIN sys.tables tbl 
ON idx.object_id = tbl.object_id
JOIN sys.index_columns ic 
ON idx.object_id = ic.object_id 
	AND idx. index_id= ic.index_id 
JOIN sys.columns col 
ON ic.object_id = col.object_id 
	AND ic.column_id = col.column_id 
ORDER BY tbl.name, col.name


--Montitor index usage
--Montiro missing indexes
--Monitor duplciate indexes
--Update Statistics
-- Monitor fragmentation


SELECT
	SCHEMA_NAME (t.schema_id) AS SchemaName, 
	t.name AS TableName,
	s.name AS StatisticName,
	sp.last_updated As LastUpdate,
	DATEDIFF (DAY, sp.last_updated, GETDATE()) AS LastUpdateDay, sp.rows AS 'Rows',
	sp.modification_counter AS ModificationsSinceLastUpdate
FROM sys.stats AS s
JOIN sys.tables t
ON s.object_id = t.object_id
CROSS APPLY sys.dm_db_stats_properties (s.object_id, s.stats_id) AS sp
ORDER BY sp.modification_counter DESC;

UPDATE STATISTICS Sales.Orders _WA_Sys_0000000B_3B75D760;
UPDATE STATISTICS Sales.Orders;
EXEC sp_updatestats;

--avg fragmentation in percent
SELECT *
FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'LIMITED')
--join with sys.tables and sys.indexes

-- < 10% fragmentation = OK
-- 10 - 30% fragmentation = do something
-- > 30% fragmentation = rebuild index

--reorganize
ALTER INDEX index_name ON Sales.Customers REORGANIZE

--rebuild
ALTER INDEX index_name ON Sales.Customers REBUILD


-- Changing execution plan 
SELECT ...
JOIN...
OPTION(HASH JOIN)

-- Changing how to read data
SELECT ...
JOIN...	WITH (FORCESEEK)

SELECT ...
JOIN...	WITH (INDEX [PK_Customer_A4AE64B87FC20A48])


--Most important tables and columns?


-- PARTITIONS

CREATE PARTITION FUNCTION PartitionByYear (DATE)
AS RANGE LEFT FOR VALUES('2023-12-31', '2024-12-31', '2025-12-31')

SELECT
	name,
	function_id,
	type,
	type_desc,
	boundary_value_on_right
FROM sys.partition_functions

ALTER DATABASE SalesDB ADD FILEGROUP FG_2023;
ALTER DATABASE SalesDB ADD FILEGROUP FG_2024;
ALTER DATABASE SalesDB ADD FILEGROUP FG_2025;
ALTER DATABASE SalesDB ADD FILEGROUP FG_2026;

ALTER DATABASE SalesDB REMOVE FILEGROUP FG_2023;

SELECT *
FROM sys.filegroups
WHERE type = 'FG'

ALTER DATABASE SalesDB ADD FILE
(
	NAME = P_2023, -- Logical Name
	FILENAME = 'C:\Program Files\Microsoft SQL Server\MSSQL16.MSSQLSERVER\MSSQL\DATA\P_2023.ndf'
) TO FILEGROUP FG_2023

ALTER DATABASE SalesDB ADD FILE
(
	NAME = P_2024, -- Logical Name
	FILENAME = 'C:\Program Files\Microsoft SQL Server\MSSQL16.MSSQLSERVER\MSSQL\DATA\P_2024.ndf'
) TO FILEGROUP FG_2024

ALTER DATABASE SalesDB ADD FILE
(
	NAME = P_2025, -- Logical Name
	FILENAME = 'C:\Program Files\Microsoft SQL Server\MSSQL16.MSSQLSERVER\MSSQL\DATA\P_2025.ndf'
) TO FILEGROUP FG_2025

ALTER DATABASE SalesDB ADD FILE
(
	NAME = P_2026, -- Logical Name
	FILENAME = 'C:\Program Files\Microsoft SQL Server\MSSQL16.MSSQLSERVER\MSSQL\DATA\P_2026.ndf'
) TO FILEGROUP FG_2026

SELECT
	fg.name AS FileGroupName,
	mf.name AS LogicalFileName,
	mf.physical_name AS PhysicalFileName,
	mf.size / 128 AS SizeInMB
FROM sys.filegroups fg
JOIN sys.master_files mf ON fg.data_space_id = mf.data_space_id
WHERE mf.database_id = DB_ID('SalesDB');

CREATE PARTITION SCHEME SchemeParititonByYear
AS PARTITION PartitionByYear
TO (FG_2023, FG_2024, FG_2025, FG_2026)


CREATE TABLE Sales.Orders_Partitioned
(
	OrderID INT,
	OrderDate DATE,
	Sales INT
) ON SchemePartitionByYear (OrderDate)
































